<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="description" content="yes-xodnd의 기술 블로그입니다."/><meta name="keywords" content="blog, frontend, javascript, css, html"/><script src="https://kit.fontawesome.com/0896a76907.js" crossorigin="anonymous"></script><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-78c217c4e1980ee43af4.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e3de07479da4f2477dea.js" as="script"/><link rel="preload" href="/_next/static/chunks/4813aa9f6a3a7a8db787066ba89005433fd68177.c79a0afc38e78f170422.js" as="script"/><link rel="preload" href="/_next/static/chunks/d904cdcacf484dbea4cab701e21603b3dc7be4b5.41139011b94d61498fd4.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-cd38c278f4fe3bd925d0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-a520d11e5d38e6188e98.js" as="script"/><style data-styled="" data-styled-version="5.2.1">@media (max-width:768px){:root{font-size:12px;}}/*!sc*/
body{margin:auto;padding:0;box-sizing:border-box;}/*!sc*/
a{color:black;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
a:visited{color:inherit;}/*!sc*/
a:hover{color:lightseagreen;}/*!sc*/
data-styled.g1[id="sc-global-ccdtUX1"]{content:"sc-global-ccdtUX1,"}/*!sc*/
.eHAsYS{padding:2rem;border-top:1px solid black;color:grey;text-align:center;font-size:0.8rem;}/*!sc*/
data-styled.g2[id="Footer__Container-qhytvz-0"]{content:"eHAsYS,"}/*!sc*/
.bUsZOM{margin:auto;max-width:1024px;}/*!sc*/
.bUsZOM i{margin-right:0.5rem;}/*!sc*/
.bUsZOM div{margin-top:0.5rem;}/*!sc*/
data-styled.g3[id="Footer__Content-qhytvz-1"]{content:"bUsZOM,"}/*!sc*/
.ehWqJ{background:white;border-bottom:1px solid black;}/*!sc*/
data-styled.g4[id="Header__Container-sc-1isb4n6-0"]{content:"ehWqJ,"}/*!sc*/
.katqRq{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:1rem;margin:auto;max-width:1024px;}/*!sc*/
data-styled.g5[id="Header__Content-sc-1isb4n6-1"]{content:"katqRq,"}/*!sc*/
.bdPGtc{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:1rem;}/*!sc*/
data-styled.g7[id="Header__Nav-sc-1isb4n6-3"]{content:"bdPGtc,"}/*!sc*/
.koMWLo{position:fixed;right:3rem;bottom:3rem;width:2rem;height:2rem;border-radius:2px;border:1px solid black;background:white;visibility:visible;-webkit-transition:200ms;transition:200ms;}/*!sc*/
.koMWLo:hover{cursor:pointer;}/*!sc*/
data-styled.g8[id="ButtonScrollUp__Button-sc-1ue24uv-0"]{content:"koMWLo,"}/*!sc*/
.jDWHvN{min-height:100vh;padding:2rem;margin:auto;max-width:768px;}/*!sc*/
data-styled.g23[id="slug__Container-sc-1egli5l-0"]{content:"jDWHvN,"}/*!sc*/
.dufqQA{margin:2rem 0 5rem;text-align:center;}/*!sc*/
data-styled.g24[id="slug__Header-sc-1egli5l-1"]{content:"dufqQA,"}/*!sc*/
.fcJkZR{margin:0 0 1rem;font-size:2rem;word-break:keep-all;}/*!sc*/
data-styled.g25[id="slug__Title-sc-1egli5l-2"]{content:"fcJkZR,"}/*!sc*/
.dEtgjY{font-size:0.8rem;}/*!sc*/
data-styled.g26[id="slug__Date-sc-1egli5l-3"]{content:"dEtgjY,"}/*!sc*/
.kqindv{line-height:1.8rem;}/*!sc*/
.kqindv a{color:lightseagreen;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
.kqindv a:hover{-webkit-text-decoration:underline;text-decoration:underline;}/*!sc*/
.kqindv a:visited{color:lightseagreen;}/*!sc*/
.kqindv img{display:block;width:90%;margin:2rem auto;padding:1rem;border:1px solid rgb(245,245,245);}/*!sc*/
.kqindv h2{margin-top:5rem;}/*!sc*/
.kqindv h3{margin-top:3rem;}/*!sc*/
.kqindv ul{padding-left:1.5rem;}/*!sc*/
.kqindv code:not([class]){padding:0.2rem 0.4rem;background-color:rgb(245,245,245);border-radius:3px;}/*!sc*/
.kqindv blockquote{margin:0;padding:0.5rem 1.5rem 0.5rem;border-left:3px solid lightseagreen;border-radius:3px;background:rgb(245,245,245);font-size:0.8rem;}/*!sc*/
.kqindv code[class*="language-"],.kqindv pre[class*="language-"]{color:#000;background:none;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.6;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;}/*!sc*/
.kqindv code[class*="language-"]::-webkit-scrollbar,.kqindv pre[class*="language-"]::-webkit-scrollbar{height:3px;}/*!sc*/
.kqindv code[class*="language-"]::-webkit-scrollbar-thumb,.kqindv pre[class*="language-"]::-webkit-scrollbar-thumb{background-color:#ccc;}/*!sc*/
.kqindv pre[class*="language-"]{padding:1em;margin:.5em 0;overflow:auto;}/*!sc*/
.kqindv:not(pre) > code[class*="language-"],.kqindv pre[class*="language-"]{background:#f9f9f9;}/*!sc*/
.kqindv:not(pre) > code[class*="language-"]{padding:.1em;border-radius:.3em;white-space:normal;}/*!sc*/
.kqindv .token.comment,.kqindv .token.block-comment,.kqindv .token.prolog,.kqindv .token.doctype,.kqindv .token.cdata{color:slategray;}/*!sc*/
.kqindv .token.punctuation{color:#999;}/*!sc*/
.kqindv .token.tag,.kqindv .token.attr-name,.kqindv .token.namespace,.kqindv .token.deleted{color:#e2777a;}/*!sc*/
.kqindv .token.function-name{color:#6196cc;}/*!sc*/
.kqindv .token.boolean,.kqindv .token.number,.kqindv .token.function{color:#ed782b;}/*!sc*/
.kqindv .token.property,.kqindv .token.class-name,.kqindv .token.constant,.kqindv .token.symbol{color:#dea702;}/*!sc*/
.kqindv .token.selector,.kqindv .token.important,.kqindv .token.atrule,.kqindv .token.keyword,.kqindv .token.builtin{color:#bb60bd;}/*!sc*/
.kqindv .token.string,.kqindv .token.char,.kqindv .token.attr-value,.kqindv .token.regex,.kqindv .token.variable{color:#2bba61;}/*!sc*/
.kqindv .token.operator,.kqindv .token.entity,.kqindv .token.url{color:#67cdcc;}/*!sc*/
.kqindv .token.important,.kqindv .token.bold{font-weight:bold;}/*!sc*/
.kqindv .token.italic{font-style:italic;}/*!sc*/
.kqindv .token.entity{cursor:help;}/*!sc*/
.kqindv .token.inserted{color:green;}/*!sc*/
data-styled.g27[id="slug__Content-sc-1egli5l-4"]{content:"kqindv,"}/*!sc*/
</style></head><body><div id="__next"><header class="Header__Container-sc-1isb4n6-0 ehWqJ"><div class="Header__Content-sc-1isb4n6-1 katqRq"><a href="/">YES-XODND BLOG</a><nav class="Header__Nav-sc-1isb4n6-3 bdPGtc"><a href="/">HOME</a><a href="/posts">POSTS</a></nav></div></header><main><section class="slug__Container-sc-1egli5l-0 jDWHvN"><div class="slug__Header-sc-1egli5l-1 dufqQA"><h1 class="slug__Title-sc-1egli5l-2 fcJkZR">React의 특징</h1><div class="slug__Date-sc-1egli5l-3 dEtgjY">Mar 10, 2021</div></div><article class="slug__Content-sc-1egli5l-4 kqindv"><p>React는 웹 서비스를 개발하기 위한 MV* 패턴에서 오로지 View만을 담당하는 라이브러리입니다. 사용자의 브라우저에 그려지는 UI를 더욱 편리하게 구현할 수 있도록, 페이스북의 개발자들은 선언형, 컴포넌트 기반, 가상 DOM 등의 기본 컨셉을 통해 React를 개발하게 되었습니다. 2013년 출시 이후 컴포넌트 기반 UI 개발 프레임워크들의 전성기를 가져온 React의 특징을 살펴보면서, 어떤 장점을 통해 가장 인기있는 웹 프론트엔드 프레임워크가 되었는지 알아보겠습니다.</p>
<h2>1. 선언형</h2>
<p>선언형이란, 명령형과 대조되는 프로그래밍 패러다임입니다. '어떻게' 해야하는지 나타내는 명령형과 달리, 선언형은 '무엇'인지를 설명하는 . 즉 React는 구현 과정에 대해 고민할 필요 없이, React에서 제공하는 인터페이스(API)를 이용해 선언하면서 UI 로직을 구현할 수 있도록 개발되었습니다. JSX를 reactElement를 거쳐 화면에 표시하는 과정이나 가상 DOM을 통한 update 과정에 대해 신경 쓸 필요가 없는 것입니다.</p>
<h2>2. 컴포넌트</h2>
<p>객체지향 프로그래밍에서 추상화된 객체들의 구성을 통해 프로그램을 구현하듯이, React는 컴포넌트 기반으로 UI를 구현합니다. 연관성 있는 DOM 요소들의 모임을 컴포넌트라는 객체로 만들고, 컴포넌트들의 구성을 통해 원하는 UI를 구현하는 것입니다. 이는 재사용성을 높이고, 연관성 있는 요소들이 모여있기 때문에 유지보수에도 용이하게 됩니다.</p>
<h3>React의 컴포넌트 정의</h3>
<p>react에서 컴포넌트는 클래스와 함수라는 두 가지 방식으로 정의할 수 있습니다. 클래스 컴포넌트는 상태를 정의할 수 있고, 다양한 라이프사이클 기능을 사용할 수 있지만 상대적으로 무겁고, 함수 컴포넌트는 상태가 없지만 가볍고 간단하게 컴포넌트를 구현할 수 있다는 장점이 있습니다. 최근에는 Hook을 통해 함수 컴포넌트에서도 상태를 사용할 수 있게 되었습니다.</p>
<h3>리액트 엘리먼트와 JSX</h3>
<p>컴포넌트를 정의하는 두 방식에는 약간의 차이가 있지만, 본질적으로는 동일한 역할을 합니다.
**'props를 입력받고, ReactElement를 반환한다'**는 것입니다.</p>
<p>대부분의 경우 클래스 컴포넌트의 <code>render()</code>나 함수 컴포넌트는 JSX를 반환하는데, <a href="https://ko.reactjs.org/docs/jsx-in-depth.html">공식문서</a>에서도 명시하고 있듯이 JSX는 <code>React.createElement()</code>를 선언적으로 사용할 수 있게 도와주는 문법적 설탕입니다. 그리고 이 함수는 ReactElement를 생성해 반환합니다. 결국 JSX를 반환한다는 것은 ReactElement 또는 ReactElement로 이루어진 트리 객체를 반환하는 것입니다.</p>
<p>ReactElement는 다음과 같은 프로퍼티를 가지고 있는 평범한 객체로, 화면에 표시할 DOM 노드에 대한 정보를 담고 있습니다.</p>
<div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> element <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// This tag allows us to uniquely identify this as a React Element</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">,</span>
  <span class="token comment">// Built-in properties that belong on the element</span>
  type<span class="token operator">:</span> type<span class="token punctuation">,</span>
  key<span class="token operator">:</span> key<span class="token punctuation">,</span>
  ref<span class="token operator">:</span> ref<span class="token punctuation">,</span>
  props<span class="token operator">:</span> props<span class="token punctuation">,</span>
  <span class="token comment">// Record the component responsible for creating this element.</span>
  _owner<span class="token operator">:</span> owner
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre></div>
<p><code>props</code> 프로퍼티는 <code>children</code>에 대한 정보를 담고 있으므로, 최상위 ReactElement는 화면에 표시할 모든 DOM 노드의 정보를 담고 있는 트리구조라고 할 수 있습니다. 즉 <a href="https://ko.reactjs.org/docs/faq-internals.html">가상 DOM의 뼈대</a>가 되는 것입니다. 그리고 이렇게 구성된 트리 구조는 ReactDOM을 통해 실제 DOM과 동기화 됩니다. 컴포넌트가 '무엇'을 표현할 지 선언했다면, ReactDOM은 '어떻게' 그것을 표현하는지를 해결해주는 것입니다.</p>
<h2>3. 가상 DOM</h2>
<p>브라우저에서 웹 페이지의 표현은 기본적으로 HTML이라는 뼈대를 통해 이루어집니다. HTML의 요소들과 텍스트들은 하나의 노드로 표현되고, 이 노드들은 DOM이라는 트리 구조로 구조화되어 있습니다. 가상 DOM이란, 이름 그대로 메모리 상에 구현된 가상의 DOM 트리입니다. 가상의 DOM 트리를 이용하면 DOM 업데이트가 발생했을 때, 이전 스냅샷과 달라진 부분만을 한 번에 일괄 처리(batch)함으로써 실제 DOM의 조작의 횟수를 줄일 수 있습니다.</p>
<p>React에서는 <code>setState()</code>등을 통해 render가 발생할 때마다 새로운 노드 트리를 만들고, 이를 ReactDOM이 기존의 트리와 비교하여 업데이트 하는 방식으로 가상 DOM의 개념을 이용하고 있습니다.</p>
<p>반응성과 DOM 조작에 대한 고민이 필요 없고, 충분히 빠르며 버그 없이 개발할 수 있다는 것은 분명한 장점입니다. 하지만 메모리에 트리를 저장해 비교하고, 실제 DOM에 변화를 적용하는 과정은 시간과 리소스를 필요로 한다는 단점이 있습니다.  이 작업은 메인 스레드에서 수행되기 때문에, 모바일에서의 제스쳐 처리나 애니메이션 업데이트처럼 UI적으로 더 중요한 작업을 방해하는 경우도 있습니다.</p>
<h3>Reconciliation => Fiber</h3>
<p>React 개발자들도 가상 DOM의 문제에 대해 인식하고 있었습니다. 이전의 diffing 알고리즘인 <code>reconciliation</code>은 가상 DOM 트리를 재귀적으로 탐색하기 때문에 작업을 멈출 수 없다는 단점이 있었습니다. 재귀 탐색이 끝나기 전까지 메인 스레드가 점유되는 것입니다. 이를 해결하기 위해 React의 개발자들은 2017년 발표한 16버전에서 Fiber라는 개선 방법을 선보였습니다.</p>
<p>페이스북의 개발자 Andrew Clark의 <a href="https://github.com/acdlite/react-fiber-architecture/blob/master/README.md">Fiber에 대한 설명</a>에 따르면, Fiber의 목적은 스케쥴링의 장점을 최대화하는 것입니다. 구체적으로 말하면 작업을 멈췄다가 돌아올 수 있고, 여러 타입의 작업에 우선순위를 부여하며, 더 이상 필요없는 작업은 중단할 수 있게 하는 것입니다. <code>requestIdleCallback</code>이나 <code>requestAnimationFrame</code> 등의 새로운 API를 이용하면 이러한 기능 구현이 가능하지만, 이를 위해서는 기존의 작업 단위를 더 잘게 쪼갤 수 있어야 합니다. 그렇지 않으면 기존의 콜 스택을 사용한 프로그램 실행과 큰 차이가 없게 되는 것입니다.</p>
<p>Fiber는 React 컴포넌트에 대한 정보를 담고 있는 자바스크립트 객체입니다. Fiber는 스택 프레임이기도 하고 컴포넌트 인스턴스이기도 합니다. Fiber는 <code>return</code> 프로퍼티를 가지고 있는데, 이는 콜 스택에서의 리턴 어드레스와 동일하게 작동합니다. 이러한 아이디어를 통해 Fiber는 가상의 콜 스택을 구현하게 되며, 위에서 언급한 스케쥴링의 장점을 구현할 수 있는 것입니다.</p>
<h2>마무리</h2>
<p>React는 '어떻게'에 대한 고민을 덜어주고, 개발자의 시간과 능력을 View 레이어 구현에 더욱 투자할 수 있도록 도와주는 라이브러리/프레임워크 입니다. 그만큼 '어떻게'에 대해 자세히 알지 않아도 되겠지만, 대략적인 특징을 이해한다면 React 앱을 개발하고 성능을 개선하는 데 도움이 될 것 같습니다.</p>
<hr>
<h3>참고자료</h3>
<ul>
<li><a href="https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca">Dan Abramov - React Components, Elements and Instances</a></li>
<li><a href="https://medium.com/react-native-seoul/react-%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A5%BC-%EC%B2%98%EC%9D%8C%EB%B6%80%ED%84%B0-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90-01-react-js%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-ad8ba252ee28">React-native-seoul - 리액트를 처음부터 배워보자. —01. React.js란 무엇인가?</a></li>
<li><a href="https://medium.com/@codesquad_yoda/%EB%82%A8%EB%8B%A4%EB%A5%B8-%EA%B0%9C%EC%84%A0%EB%B0%A9%EB%B2%95%EC%9D%84-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EC%97%AC%EC%A4%80-%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81%EC%9D%98-react-fiber-80b7ca5bd9bb">YodaCodd님 블로그 - 남다른 개선방법을 다시 보여준 페이스북의 React FIber</a></li>
<li><a href="https://simsimjae.tistory.com/473">심심재님 블로그 - React Fiber가 가지는 장점</a></li>
<li><a href="https://github.com/acdlite/react-fiber-architecture">Andrew Clark - React Fiber Architecture</a></li>
</ul>
</article></section></main><footer class="Footer__Container-qhytvz-0 eHAsYS"><div class="Footer__Content-qhytvz-1 bUsZOM"><a href="https://github.com/yes-xodnd" target="_blank" rel="noopener noreferrer "><i aria-hidden="true" class="fab fa-github"></i><span>yes-xodnd</span></a><div>ⓒ2021 ALL RIGHTS RESERVED</div></div></footer><button class="ButtonScrollUp__Button-sc-1ue24uv-0 koMWLo"><img src="../../assets/icon/up.svg" alt="up" title="맨 위로"/></button></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React의 특징","date":"2021-03-10T00:00:00.000Z","content":"\u003cp\u003eReact는 웹 서비스를 개발하기 위한 MV* 패턴에서 오로지 View만을 담당하는 라이브러리입니다. 사용자의 브라우저에 그려지는 UI를 더욱 편리하게 구현할 수 있도록, 페이스북의 개발자들은 선언형, 컴포넌트 기반, 가상 DOM 등의 기본 컨셉을 통해 React를 개발하게 되었습니다. 2013년 출시 이후 컴포넌트 기반 UI 개발 프레임워크들의 전성기를 가져온 React의 특징을 살펴보면서, 어떤 장점을 통해 가장 인기있는 웹 프론트엔드 프레임워크가 되었는지 알아보겠습니다.\u003c/p\u003e\n\u003ch2\u003e1. 선언형\u003c/h2\u003e\n\u003cp\u003e선언형이란, 명령형과 대조되는 프로그래밍 패러다임입니다. '어떻게' 해야하는지 나타내는 명령형과 달리, 선언형은 '무엇'인지를 설명하는 . 즉 React는 구현 과정에 대해 고민할 필요 없이, React에서 제공하는 인터페이스(API)를 이용해 선언하면서 UI 로직을 구현할 수 있도록 개발되었습니다. JSX를 reactElement를 거쳐 화면에 표시하는 과정이나 가상 DOM을 통한 update 과정에 대해 신경 쓸 필요가 없는 것입니다.\u003c/p\u003e\n\u003ch2\u003e2. 컴포넌트\u003c/h2\u003e\n\u003cp\u003e객체지향 프로그래밍에서 추상화된 객체들의 구성을 통해 프로그램을 구현하듯이, React는 컴포넌트 기반으로 UI를 구현합니다. 연관성 있는 DOM 요소들의 모임을 컴포넌트라는 객체로 만들고, 컴포넌트들의 구성을 통해 원하는 UI를 구현하는 것입니다. 이는 재사용성을 높이고, 연관성 있는 요소들이 모여있기 때문에 유지보수에도 용이하게 됩니다.\u003c/p\u003e\n\u003ch3\u003eReact의 컴포넌트 정의\u003c/h3\u003e\n\u003cp\u003ereact에서 컴포넌트는 클래스와 함수라는 두 가지 방식으로 정의할 수 있습니다. 클래스 컴포넌트는 상태를 정의할 수 있고, 다양한 라이프사이클 기능을 사용할 수 있지만 상대적으로 무겁고, 함수 컴포넌트는 상태가 없지만 가볍고 간단하게 컴포넌트를 구현할 수 있다는 장점이 있습니다. 최근에는 Hook을 통해 함수 컴포넌트에서도 상태를 사용할 수 있게 되었습니다.\u003c/p\u003e\n\u003ch3\u003e리액트 엘리먼트와 JSX\u003c/h3\u003e\n\u003cp\u003e컴포넌트를 정의하는 두 방식에는 약간의 차이가 있지만, 본질적으로는 동일한 역할을 합니다.\r\n**'props를 입력받고, ReactElement를 반환한다'**는 것입니다.\u003c/p\u003e\n\u003cp\u003e대부분의 경우 클래스 컴포넌트의 \u003ccode\u003erender()\u003c/code\u003e나 함수 컴포넌트는 JSX를 반환하는데, \u003ca href=\"https://ko.reactjs.org/docs/jsx-in-depth.html\"\u003e공식문서\u003c/a\u003e에서도 명시하고 있듯이 JSX는 \u003ccode\u003eReact.createElement()\u003c/code\u003e를 선언적으로 사용할 수 있게 도와주는 문법적 설탕입니다. 그리고 이 함수는 ReactElement를 생성해 반환합니다. 결국 JSX를 반환한다는 것은 ReactElement 또는 ReactElement로 이루어진 트리 객체를 반환하는 것입니다.\u003c/p\u003e\n\u003cp\u003eReactElement는 다음과 같은 프로퍼티를 가지고 있는 평범한 객체로, 화면에 표시할 DOM 노드에 대한 정보를 담고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-js\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e element \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// This tag allows us to uniquely identify this as a React Element\u003c/span\u003e\n  $$\u003cspan class=\"token keyword\"\u003etypeof\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token constant\"\u003eREACT_ELEMENT_TYPE\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// Built-in properties that belong on the element\u003c/span\u003e\n  type\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e type\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  key\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e key\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  ref\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e ref\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  props\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e props\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// Record the component responsible for creating this element.\u003c/span\u003e\n  _owner\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e owner\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eprops\u003c/code\u003e 프로퍼티는 \u003ccode\u003echildren\u003c/code\u003e에 대한 정보를 담고 있으므로, 최상위 ReactElement는 화면에 표시할 모든 DOM 노드의 정보를 담고 있는 트리구조라고 할 수 있습니다. 즉 \u003ca href=\"https://ko.reactjs.org/docs/faq-internals.html\"\u003e가상 DOM의 뼈대\u003c/a\u003e가 되는 것입니다. 그리고 이렇게 구성된 트리 구조는 ReactDOM을 통해 실제 DOM과 동기화 됩니다. 컴포넌트가 '무엇'을 표현할 지 선언했다면, ReactDOM은 '어떻게' 그것을 표현하는지를 해결해주는 것입니다.\u003c/p\u003e\n\u003ch2\u003e3. 가상 DOM\u003c/h2\u003e\n\u003cp\u003e브라우저에서 웹 페이지의 표현은 기본적으로 HTML이라는 뼈대를 통해 이루어집니다. HTML의 요소들과 텍스트들은 하나의 노드로 표현되고, 이 노드들은 DOM이라는 트리 구조로 구조화되어 있습니다. 가상 DOM이란, 이름 그대로 메모리 상에 구현된 가상의 DOM 트리입니다. 가상의 DOM 트리를 이용하면 DOM 업데이트가 발생했을 때, 이전 스냅샷과 달라진 부분만을 한 번에 일괄 처리(batch)함으로써 실제 DOM의 조작의 횟수를 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003eReact에서는 \u003ccode\u003esetState()\u003c/code\u003e등을 통해 render가 발생할 때마다 새로운 노드 트리를 만들고, 이를 ReactDOM이 기존의 트리와 비교하여 업데이트 하는 방식으로 가상 DOM의 개념을 이용하고 있습니다.\u003c/p\u003e\n\u003cp\u003e반응성과 DOM 조작에 대한 고민이 필요 없고, 충분히 빠르며 버그 없이 개발할 수 있다는 것은 분명한 장점입니다. 하지만 메모리에 트리를 저장해 비교하고, 실제 DOM에 변화를 적용하는 과정은 시간과 리소스를 필요로 한다는 단점이 있습니다.  이 작업은 메인 스레드에서 수행되기 때문에, 모바일에서의 제스쳐 처리나 애니메이션 업데이트처럼 UI적으로 더 중요한 작업을 방해하는 경우도 있습니다.\u003c/p\u003e\n\u003ch3\u003eReconciliation =\u003e Fiber\u003c/h3\u003e\n\u003cp\u003eReact 개발자들도 가상 DOM의 문제에 대해 인식하고 있었습니다. 이전의 diffing 알고리즘인 \u003ccode\u003ereconciliation\u003c/code\u003e은 가상 DOM 트리를 재귀적으로 탐색하기 때문에 작업을 멈출 수 없다는 단점이 있었습니다. 재귀 탐색이 끝나기 전까지 메인 스레드가 점유되는 것입니다. 이를 해결하기 위해 React의 개발자들은 2017년 발표한 16버전에서 Fiber라는 개선 방법을 선보였습니다.\u003c/p\u003e\n\u003cp\u003e페이스북의 개발자 Andrew Clark의 \u003ca href=\"https://github.com/acdlite/react-fiber-architecture/blob/master/README.md\"\u003eFiber에 대한 설명\u003c/a\u003e에 따르면, Fiber의 목적은 스케쥴링의 장점을 최대화하는 것입니다. 구체적으로 말하면 작업을 멈췄다가 돌아올 수 있고, 여러 타입의 작업에 우선순위를 부여하며, 더 이상 필요없는 작업은 중단할 수 있게 하는 것입니다. \u003ccode\u003erequestIdleCallback\u003c/code\u003e이나 \u003ccode\u003erequestAnimationFrame\u003c/code\u003e 등의 새로운 API를 이용하면 이러한 기능 구현이 가능하지만, 이를 위해서는 기존의 작업 단위를 더 잘게 쪼갤 수 있어야 합니다. 그렇지 않으면 기존의 콜 스택을 사용한 프로그램 실행과 큰 차이가 없게 되는 것입니다.\u003c/p\u003e\n\u003cp\u003eFiber는 React 컴포넌트에 대한 정보를 담고 있는 자바스크립트 객체입니다. Fiber는 스택 프레임이기도 하고 컴포넌트 인스턴스이기도 합니다. Fiber는 \u003ccode\u003ereturn\u003c/code\u003e 프로퍼티를 가지고 있는데, 이는 콜 스택에서의 리턴 어드레스와 동일하게 작동합니다. 이러한 아이디어를 통해 Fiber는 가상의 콜 스택을 구현하게 되며, 위에서 언급한 스케쥴링의 장점을 구현할 수 있는 것입니다.\u003c/p\u003e\n\u003ch2\u003e마무리\u003c/h2\u003e\n\u003cp\u003eReact는 '어떻게'에 대한 고민을 덜어주고, 개발자의 시간과 능력을 View 레이어 구현에 더욱 투자할 수 있도록 도와주는 라이브러리/프레임워크 입니다. 그만큼 '어떻게'에 대해 자세히 알지 않아도 되겠지만, 대략적인 특징을 이해한다면 React 앱을 개발하고 성능을 개선하는 데 도움이 될 것 같습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca\"\u003eDan Abramov - React Components, Elements and Instances\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/react-native-seoul/react-%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A5%BC-%EC%B2%98%EC%9D%8C%EB%B6%80%ED%84%B0-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90-01-react-js%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-ad8ba252ee28\"\u003eReact-native-seoul - 리액트를 처음부터 배워보자. —01. React.js란 무엇인가?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/@codesquad_yoda/%EB%82%A8%EB%8B%A4%EB%A5%B8-%EA%B0%9C%EC%84%A0%EB%B0%A9%EB%B2%95%EC%9D%84-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EC%97%AC%EC%A4%80-%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81%EC%9D%98-react-fiber-80b7ca5bd9bb\"\u003eYodaCodd님 블로그 - 남다른 개선방법을 다시 보여준 페이스북의 React FIber\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://simsimjae.tistory.com/473\"\u003e심심재님 블로그 - React Fiber가 가지는 장점\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/acdlite/react-fiber-architecture\"\u003eAndrew Clark - React Fiber Architecture\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","slug":"React의_특징"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"React의_특징"},"buildId":"kLUsgu0Kur4GXk3IM6XLt","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-144e5fa6fafab6397d9c.js"></script><script src="/_next/static/chunks/main-78c217c4e1980ee43af4.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.e3de07479da4f2477dea.js" async=""></script><script src="/_next/static/chunks/4813aa9f6a3a7a8db787066ba89005433fd68177.c79a0afc38e78f170422.js" async=""></script><script src="/_next/static/chunks/d904cdcacf484dbea4cab701e21603b3dc7be4b5.41139011b94d61498fd4.js" async=""></script><script src="/_next/static/chunks/pages/_app-cd38c278f4fe3bd925d0.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-a520d11e5d38e6188e98.js" async=""></script><script src="/_next/static/kLUsgu0Kur4GXk3IM6XLt/_buildManifest.js" async=""></script><script src="/_next/static/kLUsgu0Kur4GXk3IM6XLt/_ssgManifest.js" async=""></script></body></html>