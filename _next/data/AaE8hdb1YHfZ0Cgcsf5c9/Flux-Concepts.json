{"pageProps":{"post":{"title":"Flux 개념 이해하기","date":"2021-07-17T00:00:00.000Z","content":"<p>Ajax와 함께 프론트엔드 개발이 복잡해지면서, 그만큼 상태관리도 복잡해졌습니다. 페이스북은 2013년에 Flux라는 상태관리 디자인 패턴을 발표하였고, 여기에 영향을 받은 많은 상태관리 라이브러리가 만들어지게 되었습니다.</p>\n<p>Flux에 대해 이해하기 위해 페이스북이 작성한 Flux 가이드를 번역해보았습니다. 아래의 내용은 Facebook의 flux 레포지토리의 <a href=\"https://github.com/facebook/flux/tree/master/examples/flux-concepts\">가이드 문서</a>를 번역한 것입니다.</p>\n<h2>개요 Overview</h2>\n<hr>\n<p>Flux는 애플리케이션의 데이터 흐름을 관리하기 위한 패턴입니다. 가장 중요한 개념은 데이터가 한 방향으로만 흐른다는 것입니다. Flux 애플리케이션의 요소들을 알아보고, 어떻게 이것들이 데이터가 흐르는 단방향 사이클을 구성하는지 알아보겠습니다.</p>\n<h2>구성 요소 Flux Parts</h2>\n<hr>\n<h3>디스패처 Dispatcher</h3>\n<p>디스패처는 액션을 받아, 해당 디스패처에 등록된 스토어에 디스패치합니다.\r\n모든 스토어는 모든 액션을 받습니다.\r\n하나의 애플리케이션에 하나의 디스패처만 존재해야 합니다.</p>\n<p>예시:</p>\n<ol>\n<li>사용자가 todo에 제목을 입력하고 엔터 버튼을 누릅니다.</li>\n<li>view는 해당 이벤트를 감지하고 입력된 제목을 포함하는 \"add-todo\" 액션을 디스패치합니다.</li>\n<li>모든 스토어는 해당 액션을 받습니다.</li>\n</ol>\n<h3>스토어 Store</h3>\n<p>스토어는 애플리케이션의 데이터를 가지고 있습니다.  스토어는 애플리케이션의 디스패처에 등록하여 액션을 받을 수 있습니다. 스토어의 데이터는 액션에 응답함으로써만 변경될 수 있어야 합니다. 퍼블릭 setter가 존재해서는 안되고, getter만 제공해야 합니다. 스토어는 어떤 액션에 반응할지 결정해야 합니다. 스토어의 데이터가 변경될 때마다, 스토어는 \"change\"이벤트를 내보내야 합니다. 각 애플리케이션에 여러 스토어가 있을 수 있습니다.</p>\n<h3>액션 Actions</h3>\n<p>액션은 애플리케이션의 내부 API를 정의합니다. 액션은 \"type\" 필드와 데이터를 가지고 있는 단순한 객체입니다. 액션은 시맨틱하고 발생하는 동작에 대해 서술적이어야 합니다. 해당 액션이 구현되는 디테일에 대해서는 서술할 필요가 없습니다.</p>\n<p>예시:</p>\n<ol>\n<li>사용자가 완료한 todo 아이템의 \"삭제\" 버튼을 클릭하면, \"delete-todo\" 액션이 디스패치 됩니다.</li>\n</ol>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'delete-todo'</span><span class=\"token punctuation\">,</span>\n  todoID<span class=\"token operator\">:</span> <span class=\"token string\">'123'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3>뷰 Views</h3>\n<p>스토어의 데이터는 뷰에 표시됩니다. 뷰는 어떤 프레임워크라도 사용될 수 있습니다. 뷰가 스토어의 데이터를 사용하면 뷰는 반드시 스토어의 \"change\" 이벤트를 구독해야 합니다. 그리고 스토어가 \"change\" 이벤트를 내보내면, 뷰는 바뀐 데이터를 받아 리렌더링을 수행할 수 있습니다. 만약 컴포넌트가 스토어의 데이터를 사용하고 구독하지는 않았다면, 발견하기 어려운 버그가 발생할 수 있습니다. 사용자는 애플리케이션의 인터페이스와 상호작용하므로, 액션은 일반적으로 뷰에서 디스패치됩니다.</p>\n<p>예시:</p>\n<ol>\n<li>main 뷰가 TodoStore를 구독합니다.</li>\n<li>main 뷰는 Todos의 목록에 접근하여 사용자가 상호작용할 수 있는 포맷으로 렌더링 합니다.</li>\n<li>유저가 새로운 Todo의 제목을 입력하고 엔터 버튼을 누르면, 뷰는 디스패처에게 액션을 디스패치하도록 알립니다.</li>\n<li>모든 스토어는 디스패치된 액션을 받습니다.</li>\n<li>TodoStore는 액션을 처리하고, 새로운 Todo를 내부 자료구조에 추가한다음 \"change\" 이벤트를 내보냅니다.</li>\n<li>main 뷰는 \"change\" 이벤트를 구독하고 있습니다. 이벤트를 포착한 main 뷰는 TodoStore에서 새로운 데이터를 받고, 사용자 인터페이스에 Todo 목록을 리렌더링 합니다.</li>\n</ol>\n<h2>데이터의 흐름</h2>\n<p>위에서 알아본 Flux의 구성 요소들을 이어붙여, 시스템에서 데이터가 어떻게 흘러가는지를 묘사하는 다이어그램을 만들 수 있습니다.</p>\n<ol>\n<li>뷰는 액션을 디스패처에 보냅니다.</li>\n<li>디스패처는 액션을 모든 스토어에 보냅니다.</li>\n<li>스토어는 데이터를 뷰에 보냅니다.</li>\n</ol>\n<p><img src=\"https://github.com/facebook/flux/raw/master/examples/flux-concepts/flux-simple-f8-diagram-with-client-action-1300w.png\" alt=\"Data flow within Flux application\"></p>\n<p>(다이어그램에는 뷰에서 발생하지 않는 액션을 의미하는 액션 노드가 하나 더 있습니다.)</p>\n","slug":"Flux-Concepts"}},"__N_SSG":true}